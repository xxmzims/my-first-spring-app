==========Контроллеры=============
Для чего нужен контроллер?

1. Обмениваться данными с моделью
2. Обрабатывает запросы от пользователя(HTTP-запросы)
3. Показывает пользователю правильное представление
4. Переадресация пользователя на другие страницы

Аннотация @Controller

Наследуется от @Component, а значит Spring воспринимает ее как зависимость и работает с ней точно также

Внутри классов, помеченных аннотацией @Controller может быть неограниченное кол-во методов
Обычно, но не всегда каждый метод берет на себя один URL
Обычно, но не всегда, каждый метод возвращает строку название представление, которое надо показать пользователю
У методов может быть любое значение

=======Маппинги=====
 Связывают метод контроллера с адресом, по которому можно обратиться к этому методу (из браузера например)

 Различают 5 видом маппинга - в зависимости от того, какой HTTP запрос(с каким HTTP методом) должен прийти
  в этот метод контроллера

  @GetMapping("/hello-world") - говорит, что мы хотим обрабатывать GET-запросы от пользователя по указанному URl
  @RequestMapping("/people") на уровне класса, означает, что мы хотим, чтобы все методы класса работали с одним
   указанным url

========Параметры get-запроса===========

Параметры передаются в URl запроса

Параметры представляют собой пары ключ=значение, передаются после символа ?, разделяются знаком &(аспирант).
Пример http://localhost:8080/first/hello?name=maks&surname=ugr

 С помощью аннотации @RequestParam можно обрабатывать переданные в url параметры
 Если параметры не указаны будет вызваны ошибка, чтобы ошибки не было и наши параметры были null,
  следует использовать параметр у аннотации required со значением false
  Пример @RequestParam(value = "name", required = false)

Также для получения параметров можно использовать класс HttpServletRequest и его метод getParam().
В этом случае если в url не указаны параметры, они будут null

========CRUD=========
Стандартная классификация функций по манипуляции данными
1. CREATE
2. READ
3. UPDATE
4. DELETE

==========REST==========
1. REST - это паттерн проектирования web-приложений
2. REST описывает то, как посредством протокола HTTP, должен взаимодействовать клиент с сервером
3. Всё взаимодействие с сервером сводится к 4 операциям - получение данных, добавление новых данных,
                                                изменение существующих даных, удаление данных
4. Для каждой из 4 операций используется свой HTTP метод - GET, POST, PATCH, DELETE
(Это не все правила и ограничения REST приложений)

==========DAO(Data Access Object)============
Паттерн проектирования, когда отдельный класс занимается взаимодействием с БД для конкретной сущности.

В DAO-классах обычно пишут SQL-код работы с БД приложений

=======Базы данных======
 Связь Java приложения с БД
 JDBC API - самый низкоуровневый(сами делаем запросы к БД и сами переводим Java-объекты в
                                                    строки и таблицы и наооборот)
JdbcTemplate - тонкая обертква вокруг JDBC API. Часть Spring Framework.
                                    Предоставляет некоторые абсракции, берет часть дел на себя.
Hibernate - самый высокий уровень абстракции. Практиечески не пишем вручную запросы к БД.
Автоматически переводит Java-объекты в строки таблицы и наооборот.
Может автоматически создавать таблицы в БД на основании наших Java-классов.
Этот функционал называется ORM(англ. Object-Relational Mapping).


==========Batch Update(Пакетное обновление)==========

Отправка данных в БД пакетами, а не по одному запросы позволяет БД распаралерить операции
вставки на несколько потоков (в зависимости от доступных ресурсов)

========Инкреминтация в БД==========
Использование типа SERIAL: При создании таблицы можно использовать тип SERIAL для поля идентификатора.
Использование GENERATED BY DEFAULT AS IDENTITY: Начиная с PostgreSQL 10, можно использовать новый способ
 генерации идентификаторов с помощью GENERATED BY DEFAULT AS IDENTITY(лучше всего использовать его, так как стандартизацию никто не отменял)

=========Ограничения в БД==============
Самый пополурные:
NOT NULL - устанавливается на колонку, указывает на то, что значение не может быть null
UNIQUE - уставливает на колонку, указывает на то, что все значения должны быть уникальными
PRIMARY KEY = UNIQUE + NOT NULL(первичный ключ), в таблице может быть только одна колонка PRIMARY KEY

FOREIGN KEY - Внешник ключ. Используется для связывания таблиц
CHECK - можем указывать пользовательские ограничения(VALUE > 0)

Двойная валидация - это нормально. Ограничения обычно ставяться как на самом приложении(для отрисовки
красивых сообщений об ошибке дляь пользователя) и на БД (чтобы технически невозможно было поместить неправильное значение)

================Отношения(Связи) в БД=============
Relation - отношение, связь
Между таблицами в реляционных БЛ есть связь

Виды Отношений в БД:
Один ко многим(One to Many)
PK(primary key) содержит только уникальные значения, FK может содержать дубликаты
Таблица, содержащая FK, дочерняя. Таблица, содержащая только РК - родительская.
Один заказ не может принадлежать нескольким людям, так как на order_id ограничение primary key

Один к одному(One to one)
Отношение "один к одному" (1:1) в реляционных базах данных означает, что одной записи
в одной таблице соответствует ровно одна запись в другой таблице. Это отношение используется
 для разделения связанных, но различных типов данных, которые логически связаны между собой.
В дочерней таблице FK=PK

Многие ко многим(Many to many)
Отношение "многие ко многим" (N:M) в реляционных базах данных указывает на то,
что одна запись в одной таблице может соответствовать многим записям в другой таблице, и наоборот.
Это распространенное отношение, которое используется для моделирования сложных взаимосвязей между сущностями.
Использует составной PK, исключая при этом дубликаты одинаковых связей

==============JOIN запросы============
Временной обьеденение двух таблиц в одну денормализованную осуществлятся для удоного просмотра данных
При таком обьединении не создается новая таблица в БД

                        Виды JOIN'ов
INNER JOIN - это операция объединения, которая возвращает только те строки,
которые имеют соответствующие значения в обеих таблицах, участвующих в объединении.

OUTER JOIN's
1.LEFT OUTER JOIN. Используется для объединения двух таблиц, но с сохранением всех записей из левой таблицы,
в том числе и тех, для которых нет соответствующих записей в правой таблице. Он возвращает все строки
из левой таблицы и совпадающие строки из правой таблицы. Если совпадений нет, то для столбцов правой
таблицы используются значения NULL.
2.RIGHT OUTER JOIN. Используется для объединения двух таблиц, но для сохранения всех записей из правой таблицы,
в том числе и тех, для которых нет соответствующих записей в левой таблице. Он возвращает все строки из правой
 таблицы и совпадающие строки из левой таблицы. Если совпадений нет, то для столбцов левой таблицы используются значения NULL.
 (почти никогда не используется, ибо можно заменить легко LEFT JOIN'ом)
3.FULL OUTER JOIN. Используется для объединения двух таблиц с сохранением всех записей, включая те,
для которых нет соответствующих записей в другой таблице. Он возвращает все строки, если есть совпадение либо в левой,
либо в правой таблице. Если совпадения нет, то в столбцах таблицы, в которой нет совпадения, используются значения NULL.

CROSS JOIN - это инструмент, создающий декартово произведение двух таблиц.
Он подходит для генерации всех возможных комбинаций данных из этих таблиц.
Декартово произведение (прямое произведение) — множество, элементами которого являются все возможные
упорядоченные пары элементов заданных двух непустых исходных множеств.